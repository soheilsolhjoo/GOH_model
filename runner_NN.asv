clear; clc; close all;
%% Load Data
global sb_11 sb_22 sx_11 sx_22 sy_11 sy_22
% global lam_sb lam_sx lam_sy
global ss_11 ss_22
load_data
ss_data = [ss_11 ss_22];
lambda  = [ss_data(:,1) ss_data(:,3)];
stress  = [ss_data(:,2) ss_data(:,4)];
lambda  = F_construct(lambda); %now Lambda = F = diag(l11,l22,l33)
%% Energy
W_b = exp_strain_energy([sb_11 sb_22]);
W_b = W_b - W_b(1);
W_1 = exp_strain_energy([sx_11 sx_22]);
W_1 = W_1 - W_1(1);
W_2 = exp_strain_energy([sy_11 sy_22]);
W_2 = W_2 - W_2(1);

F0 = lambda';           % X
W0 = [W_b;W_1;W_2]';    % Y
%% Deep NN
numLayers = 3;
numNeurons = 5;

parameters = struct;
sz = [numNeurons 3];
parameters.fc1_Weights = initializeHe(sz,1,"double");
parameters.fc1_Bias = initializeZeros([numNeurons 1],"double");
for layerNumber=2:numLayers-1
    name = "fc"+layerNumber;

    sz = [numNeurons numNeurons];
    numIn = numNeurons;
    parameters.(name + "_Weights") = initializeHe(sz,numIn,"double");
    parameters.(name + "_Bias") = initializeZeros([numNeurons 1],"double");
end
sz = [1 numNeurons];
numIn = numNeurons;
parameters.("fc" + numLayers + "_Weights") = initializeHe(sz,numIn,"double");
parameters.("fc" + numLayers + "_Bias") = initializeZeros([1 1],"double");
%% fmincon options
iter = 1000;
options = optimoptions("fmincon", ...
    HessianApproximation="lbfgs", ...
    MaxIterations=iter, ...
    MaxFunctionEvaluations=iter, ...
    OptimalityTolerance=1e-5, ...
    SpecifyObjectiveGradient=true);
%%
[parametersV,parameterNames,parameterSizes] = parameterStructToVector(parameters);
parametersV = extractdata(parametersV);

F0 = dlarray(F0,"CB");
W0 = dlarray(W0,"CB");

objFun = @(parameters) ...
    objectiveFunction(parameters,F0,W0,parameterNames,parameterSizes);
parametersV = fmincon(objFun,parametersV,[],[],[],[],[],[],[],options);

parameters = parameterVectorToStruct(parametersV,parameterNames,parameterSizes);
save('parameters','parameters');
%% fmincon
function [loss,gradientsV] = objectiveFunction(parametersV,F0,W0,parameterNames,parameterSizes)

% Convert parameters to structure of dlarray objects.
parametersV = dlarray(parametersV);
parameters = parameterVectorToStruct(parametersV,parameterNames,parameterSizes);

% Evaluate model loss and gradients.
[loss,gradients] = dlfeval(@modelLoss,parameters,F0,W0);

% Return loss and gradients for fmincon.
gradientsV = parameterStructToVector(gradients);
gradientsV = extractdata(gradientsV);
loss = extractdata(loss);

end
%%
function [loss,gradients] = modelLoss(parameters,F0,W0)

% % Make predictions with the initial conditions.
% U = model(parameters,X,T);
% 
% % Calculate derivatives with respect to X and T.
% gradientsU = dlgradient(sum(U,"all"),{X,T},EnableHigherDerivatives=true);
% Ux = gradientsU{1};
% Ut = gradientsU{2};
% 
% % Calculate second-order derivatives with respect to X.
% Uxx = dlgradient(sum(Ux,"all"),X,EnableHigherDerivatives=true);
% 
% % Calculate mseF. Enforce Burger's equation.
% f = Ut + U.*Ux - (0.01./pi).*Uxx;
% zeroTarget = zeros(size(f),"like",f);
% mseF = l2loss(f, zeroTarget);

% Calculate mseU. Enforce initial and boundary conditions.
W0Pred = model(parameters,F0);
mseU = l2loss(W0Pred, W0);

% Calculated loss to be minimized by combining errors.
% loss = mseF + mseU;
loss = mseU;

% Calculate gradients with respect to the learnable parameters.
gradients = dlgradient(loss,parameters);

end



%% evaluate

W_pred = model(parameters,F0);

tTest = [0.25 0.5 0.75 1];
numPredictions = 1001;
XTest = linspace(-1,1,numPredictions);
XTest = dlarray(XTest,"CB");

figure
for i=1:numel(tTest)
    t = tTest(i);
    TTest = t*ones(1,numPredictions);
    TTest = dlarray(TTest,"CB");

    % Make predictions.
    UPred = model(parameters,XTest,TTest);

    % Calcualte true values.
    UTest = solveBurgers(extractdata(XTest),t,0.01/pi);

    % Calculate error.
    UPred = extractdata(UPred);
    err = norm(UPred - UTest) / norm(UTest);

    % Plot predictions.
    subplot(2,2,i)
    plot(XTest,UPred,"-",LineWidth=2);
    ylim([-1.1, 1.1])

    % Plot true values.
    hold on
    plot(XTest, UTest,"--",LineWidth=2)
    hold off

    title("t = " + t + ", Error = " + gather(err));
end

subplot(2,2,2)
legend(["Predicted" "True"])











% 
% 
% 
% figure
% C = colororder;
% lineLoss = animatedline(Color=C(2,:));
% ylim([0 inf])
% xlabel("Iteration")
% ylabel("Loss")
% grid on
% 
% for i = 1:numEpochs
%     [net, solverState] = lbfgsupdate(net,lossFcn,solverState);
% 
%     updateInfo(monitor,Epoch=i);
%     recordMetrics(monitor,i,TrainingLoss=solverState.Loss);
% end
% 
% function [loss,gradients] = modelLoss(net,F0,W0)
% 
% % Make predictions with the initial conditions.
% % XT = cat(1,X,T);
% W_net = forward(net,F0);
% 
% % % Calculate derivatives with respect to X and T.
% % gradientsU = dlgradient(sum(U,"all"),{X,T},EnableHigherDerivatives=true);
% % Ux = gradientsU{1};
% % Ut = gradientsU{2};
% % 
% % % Calculate second-order derivatives with respect to X.
% % Uxx = dlgradient(sum(Ux,"all"),X,EnableHigherDerivatives=true);
% % 
% % % Calculate mseF. Enforce Burger's equation.
% % f = Ut + U.*Ux - (0.01./pi).*Uxx;
% % zeroTarget = zeros(size(f),"like",f);
% % mseF = l2loss(f,zeroTarget);
% % 
% % % Calculate mseU. Enforce initial and boundary conditions.
% % XT0 = cat(1,X0,T0);
% % U0Pred = forward(net,XT0);
% % mseU = l2loss(U0Pred,U0);
% % 
% % % Calculated loss to be minimized by combining errors.
% % loss = mseF + mseU;
% 
% loss = sum((W_net - W0).^2, 'all');
% 
% % Calculate gradients with respect to the learnable parameters.
% gradients = dlgradient(loss,net.Learnables);
% 
% end


%%
% %% Optimization
% % c: C10, k1, k2, kappa, [theta(s)(in degrees)]
% % NOTE: the number of directions should be known.
% % The direction can changes between 0 and 180 degrees
% % c0  = [0, 0, 0, 0, [95,85]]; %the last [] is to list all directions
%
% file_name = "optC\orient_1.mat";
% train = 0;
%
% if train
%     c0 =[0, 0, 0, 0, [85]]; %#ok
%     [optC_GS, fval, W_func]  = W_calibrator(lambda, stress, c0);
%     save(file_name, "optC_GS","fval", "W_func", '-mat');
% else
%     load(file_name)
% end
% % g   = calc_g(c0(5:end));
% % inv = calc_l2i(g, lambda);
% % psi = calc_i2p(c0, inv);
% % der = calc_der(c0, inv);
% % sig = calc_sig(c0, lambda);
% %% Visualize the results
% sb_temp = F_construct([ linspace(lam_sb(1,1),lam_sb(end,1))', ...
%             linspace(lam_sb(1,2),lam_sb(end,2))']);
% sx_temp = F_construct([ linspace(lam_sx(1,1),lam_sx(end,1))', ...
%             linspace(lam_sx(1,2),lam_sx(end,2))']);
% sy_temp = F_construct([ linspace(lam_sy(1,1),lam_sy(end,1))', ...
%             linspace(lam_sy(1,2),lam_sy(end,2))']);
%
% subplot(3,1,1)
% sb_GOH_GS = W_func(optC_GS, sb_temp);
% ss_plot([sb_11 sb_22],"Equibiaxial")
% hold on;
% plot(sb_temp(:,1),sb_GOH_GS(:,1),'b-')
% plot(sb_temp(:,2),sb_GOH_GS(:,2),'r-')
% hold off
%
% subplot(3,1,2)
% sx_GOH_GS = W_func(optC_GS, sx_temp);
% ss_plot([sx_11 sx_22],"Off-biaxial X")
% hold on;
% plot(sx_temp(:,1),sx_GOH_GS(:,1),'b-')
% plot(sx_temp(:,2),sx_GOH_GS(:,2),'r-')
% hold off
%
% subplot(3,1,3)
% sy_GOH_GS = W_func(optC_GS, sy_temp);
% ss_plot([sy_11 sy_22],"Off-biaxial Y")
% hold on;
% plot(sy_temp(:,1),sy_GOH_GS(:,1),'b-')
% plot(sy_temp(:,2),sy_GOH_GS(:,2),'r-')
% hold off
% %% Compare energies
% cal_e = zeros(size(sb_temp,1),1);
% for i = 1:2
%     cal_e(:,1) = cal_e(:,1) + cumtrapz(log(sb_temp(:,i)), sb_GOH_GS(:,i));
% end
%
% g   = calc_g(optC_GS(5:end));
% inv = calc_l2i(g, sb_temp);
% energy = calc_i2p(optC_GS, inv);
% % energy = GOH_energy(optC_GS,invariants);
% e_temp = energy - energy(1);
% % close all
% figure
% hold on
% plot(e_temp,cal_e,'b*');
% pline = [min(e_temp) ceil(max(e_temp)*1000)/1000];
% plot(pline,pline,'r-');
% hold off